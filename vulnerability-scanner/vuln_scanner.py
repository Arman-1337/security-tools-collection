#!/usr/bin/env python3
"""
Vulnerability Scanner Tool
Automated web application vulnerability scanner.
"""

import socket
import ssl
import requests
import re
from urllib.parse import urljoin, urlparse
from datetime import datetime
import sys

class VulnerabilityScanner:
    """Scanner for common web application vulnerabilities."""
    
    def __init__(self, target_url):
        """Initialize vulnerability scanner."""
        self.target_url = target_url
        self.vulnerabilities = []
        self.scan_results = {
            'sql_injection': [],
            'xss': [],
            'security_headers': {},
            'ssl_issues': [],
            'information_disclosure': [],
            'open_ports': []
        }
        
        # Common SQL injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "1' OR '1' = '1",
            "' OR 1=1--",
            "\" OR \"1\"=\"1",
            "' UNION SELECT NULL--"
        ]
        
        # Common XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>"
        ]
    
    def print_banner(self):
        """Print scanner banner."""
        print("\n" + "=" * 60)
        print("VULNERABILITY SCANNER - Security Tools Collection")
        print("=" * 60)
        print(f"Target: {self.target_url}")
        print(f"Scan Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("=" * 60 + "\n")
    
    def check_sql_injection(self):
        """Check for SQL injection vulnerabilities."""
        print("üîç Testing for SQL Injection vulnerabilities...")
        
        try:
            # Get the base page
            response = requests.get(self.target_url, timeout=5)
            base_length = len(response.text)
            
            for payload in self.sql_payloads:
                test_url = f"{self.target_url}?id={payload}"
                
                try:
                    test_response = requests.get(test_url, timeout=5)
                    
                    # Check for SQL error messages
                    sql_errors = [
                        'SQL syntax',
                        'mysql_fetch',
                        'ORA-',
                        'PostgreSQL',
                        'SQLite',
                        'SQLSTATE',
                        'Unclosed quotation',
                        'Microsoft SQL'
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in test_response.text.lower():
                            vuln = {
                                'type': 'SQL Injection',
                                'severity': 'HIGH',
                                'payload': payload,
                                'evidence': f'SQL error message found: {error}'
                            }
                            self.scan_results['sql_injection'].append(vuln)
                            print(f"  ‚ùå VULNERABLE: SQL error detected with payload: {payload[:30]}...")
                            break
                    
                    # Check for abnormal response length
                    if abs(len(test_response.text) - base_length) > 100:
                        print(f"  ‚ö†Ô∏è  Potential SQLi: Abnormal response with payload: {payload[:30]}...")
                        
                except requests.RequestException:
                    pass
            
            if not self.scan_results['sql_injection']:
                print("  ‚úì No SQL Injection vulnerabilities detected")
                
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error testing SQL injection: {str(e)}")
    
    def check_xss(self):
        """Check for Cross-Site Scripting (XSS) vulnerabilities."""
        print("\nüîç Testing for XSS vulnerabilities...")
        
        try:
            for payload in self.xss_payloads:
                test_url = f"{self.target_url}?search={payload}"
                
                try:
                    response = requests.get(test_url, timeout=5)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        vuln = {
                            'type': 'XSS (Reflected)',
                            'severity': 'MEDIUM',
                            'payload': payload,
                            'evidence': 'Payload reflected in response'
                        }
                        self.scan_results['xss'].append(vuln)
                        print(f"  ‚ùå VULNERABLE: XSS payload reflected: {payload[:30]}...")
                        
                except requests.RequestException:
                    pass
            
            if not self.scan_results['xss']:
                print("  ‚úì No XSS vulnerabilities detected")
                
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error testing XSS: {str(e)}")
    
    def check_security_headers(self):
        """Check for missing security headers."""
        print("\nüîç Checking security headers...")
        
        important_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': 'DENY or SAMEORIGIN',
            'Strict-Transport-Security': 'HSTS',
            'Content-Security-Policy': 'CSP',
            'X-XSS-Protection': '1; mode=block',
            'Referrer-Policy': 'no-referrer or strict-origin'
        }
        
        try:
            response = requests.get(self.target_url, timeout=5)
            headers = response.headers
            
            for header, description in important_headers.items():
                if header in headers:
                    self.scan_results['security_headers'][header] = {
                        'present': True,
                        'value': headers[header]
                    }
                    print(f"  ‚úì {header}: {headers[header]}")
                else:
                    self.scan_results['security_headers'][header] = {
                        'present': False,
                        'recommendation': description
                    }
                    print(f"  ‚ùå Missing: {header} ({description})")
                    
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error checking headers: {str(e)}")
    
    def check_ssl_tls(self):
        """Check SSL/TLS configuration."""
        print("\nüîç Checking SSL/TLS configuration...")
        
        if not self.target_url.startswith('https://'):
            print("  ‚ö†Ô∏è  WARNING: Site does not use HTTPS!")
            self.scan_results['ssl_issues'].append("No HTTPS")
            return
        
        try:
            hostname = urlparse(self.target_url).netloc
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, 443), timeout=5) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    protocol = ssock.version()
                    
                    print(f"  ‚úì SSL/TLS Version: {protocol}")
                    print(f"  ‚úì Certificate Subject: {dict(x[0] for x in cert['subject'])}")
                    print(f"  ‚úì Certificate Issuer: {dict(x[0] for x in cert['issuer'])}")
                    
                    # Check for weak protocols
                    weak_protocols = ['TLSv1', 'TLSv1.1', 'SSLv2', 'SSLv3']
                    if protocol in weak_protocols:
                        print(f"  ‚ùå WARNING: Weak protocol detected: {protocol}")
                        self.scan_results['ssl_issues'].append(f"Weak protocol: {protocol}")
                    
        except ssl.SSLError as e:
            print(f"  ‚ùå SSL Error: {str(e)}")
            self.scan_results['ssl_issues'].append(str(e))
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error checking SSL: {str(e)}")
    
    def check_information_disclosure(self):
        """Check for information disclosure issues."""
        print("\nüîç Checking for information disclosure...")
        
        try:
            response = requests.get(self.target_url, timeout=5)
            
            # Check for server information
            if 'Server' in response.headers:
                server = response.headers['Server']
                print(f"  ‚ö†Ô∏è  Server information disclosed: {server}")
                self.scan_results['information_disclosure'].append(f"Server: {server}")
            
            if 'X-Powered-By' in response.headers:
                powered = response.headers['X-Powered-By']
                print(f"  ‚ö†Ô∏è  Technology disclosed: {powered}")
                self.scan_results['information_disclosure'].append(f"X-Powered-By: {powered}")
            
            # Check for common sensitive files
            sensitive_files = [
                'robots.txt',
                '.git/config',
                '.env',
                'config.php',
                'web.config',
                'phpinfo.php'
            ]
            
            for file in sensitive_files:
                test_url = urljoin(self.target_url, file)
                try:
                    file_response = requests.get(test_url, timeout=3)
                    if file_response.status_code == 200:
                        print(f"  ‚ùå Sensitive file accessible: {file}")
                        self.scan_results['information_disclosure'].append(f"File: {file}")
                except:
                    pass
            
            if not self.scan_results['information_disclosure']:
                print("  ‚úì No obvious information disclosure detected")
                
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error checking information disclosure: {str(e)}")
    
    def scan_common_ports(self):
        """Scan for commonly open ports."""
        print("\nüîç Scanning common ports...")
        
        try:
            hostname = urlparse(self.target_url).netloc.split(':')[0]
            common_ports = [21, 22, 23, 25, 80, 443, 3306, 3389, 5432, 8080, 8443]
            
            print(f"  Scanning {hostname}...")
            
            for port in common_ports:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((hostname, port))
                
                if result == 0:
                    print(f"  ‚ö†Ô∏è  Port {port} is OPEN")
                    self.scan_results['open_ports'].append(port)
                
                sock.close()
            
            if not self.scan_results['open_ports']:
                print("  ‚úì No unexpected ports open")
            
        except Exception as e:
            print(f"  ‚ö†Ô∏è  Error scanning ports: {str(e)}")
    
    def generate_report(self):
        """Generate vulnerability scan report."""
        print("\n" + "=" * 60)
        print("VULNERABILITY SCAN REPORT")
        print("=" * 60)
        
        total_vulns = (
            len(self.scan_results['sql_injection']) +
            len(self.scan_results['xss']) +
            len(self.scan_results['ssl_issues']) +
            len(self.scan_results['information_disclosure'])
        )
        
        # Count missing security headers
        missing_headers = sum(
            1 for header in self.scan_results['security_headers'].values()
            if not header.get('present', False)
        )
        
        print(f"\nTarget: {self.target_url}")
        print(f"Total Vulnerabilities Found: {total_vulns}")
        print(f"Missing Security Headers: {missing_headers}")
        print(f"Open Ports: {len(self.scan_results['open_ports'])}")
        
        # High severity issues
        print("\n" + "-" * 60)
        print("HIGH SEVERITY ISSUES:")
        print("-" * 60)
        
        high_severity = []
        
        if self.scan_results['sql_injection']:
            high_severity.append("SQL Injection vulnerabilities detected")
            for vuln in self.scan_results['sql_injection']:
                print(f"  ‚ùå {vuln['type']}: {vuln['evidence']}")
        
        if not high_severity:
            print("  ‚úì No high severity issues found")
        
        # Medium severity issues
        print("\n" + "-" * 60)
        print("MEDIUM SEVERITY ISSUES:")
        print("-" * 60)
        
        if self.scan_results['xss']:
            for vuln in self.scan_results['xss']:
                print(f"  ‚ö†Ô∏è  {vuln['type']}: {vuln['evidence']}")
        
        if self.scan_results['ssl_issues']:
            for issue in self.scan_results['ssl_issues']:
                print(f"  ‚ö†Ô∏è  SSL/TLS Issue: {issue}")
        
        if not self.scan_results['xss'] and not self.scan_results['ssl_issues']:
            print("  ‚úì No medium severity issues found")
        
        # Recommendations
        print("\n" + "-" * 60)
        print("RECOMMENDATIONS:")
        print("-" * 60)
        
        recommendations = []
        
        if self.scan_results['sql_injection']:
            recommendations.append("Implement parameterized queries to prevent SQL injection")
        
        if self.scan_results['xss']:
            recommendations.append("Implement input validation and output encoding")
        
        if missing_headers > 0:
            recommendations.append("Add missing security headers to HTTP responses")
        
        if self.scan_results['ssl_issues']:
            recommendations.append("Update SSL/TLS configuration to use strong protocols")
        
        if self.scan_results['information_disclosure']:
            recommendations.append("Remove server version information from headers")
        
        if not recommendations:
            recommendations.append("Maintain current security posture with regular scans")
        
        for i, rec in enumerate(recommendations, 1):
            print(f"  {i}. {rec}")
        
        print("\n" + "=" * 60)
        print("Scan completed at:", datetime.now().strftime('%Y-%m-%d %H:%M:%S'))
        print("=" * 60 + "\n")
    
    def run_scan(self):
        """Run complete vulnerability scan."""
        self.print_banner()
        
        print("Starting comprehensive vulnerability scan...\n")
        
        self.check_sql_injection()
        self.check_xss()
        self.check_security_headers()
        self.check_ssl_tls()
        self.check_information_disclosure()
        self.scan_common_ports()
        
        self.generate_report()

def main():
    """Main function to run vulnerability scanner."""
    print("\n" + "=" * 60)
    print("VULNERABILITY SCANNER TOOL")
    print("=" * 60)
    print("\nAutomated web application security scanner")
    print("Tests for: SQL Injection, XSS, Security Headers, SSL/TLS, etc.\n")
    
    if len(sys.argv) > 1:
        target_url = sys.argv[1]
    else:
        target_url = input("Enter target URL (e.g., http://testphp.vulnweb.com): ").strip()
    
    if not target_url:
        print("‚ùå Error: No target URL specified")
        sys.exit(1)
    
    # Add http:// if no protocol specified
    if not target_url.startswith(('http://', 'https://')):
        target_url = 'http://' + target_url
    
    print(f"\n‚ö†Ô∏è  WARNING: Only scan websites you own or have permission to test!")
    confirm = input("Do you have authorization to scan this target? (yes/no): ").lower()
    
    if confirm != 'yes':
        print("\n‚ùå Scan cancelled. Always obtain proper authorization!")
        sys.exit(0)
    
    try:
        scanner = VulnerabilityScanner(target_url)
        scanner.run_scan()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Scan interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(f"\n‚ùå Error: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()
